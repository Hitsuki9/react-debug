{"version":3,"file":"react-jsx-runtime.production.js","sources":["../../../../packages/shared/ReactSymbols.js","../../../../packages/react/src/jsx/ReactJSXElement.js","../../../../packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_PROVIDER_TYPE: symbol = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_DEBUG_TRACING_MODE_TYPE: symbol = Symbol.for(\n  'react.debug_trace_mode',\n);\nexport const REACT_OFFSCREEN_TYPE: symbol = Symbol.for('react.offscreen');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isValidElementType from 'shared/isValidElementType';\nimport isArray from 'shared/isArray';\nimport {describeUnknownElementTypeFrameInDEV} from 'shared/ReactComponentStackFrame';\nimport {\n  disableDefaultPropsExceptForClasses,\n  enableOwnerStacks,\n} from 'shared/ReactFeatureFlags';\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && enableOwnerStacks && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    if (enableOwnerStacks) {\n      Object.defineProperty(element, '_debugStack', {\n        configurable: false,\n        enumerable: false,\n        writable: true,\n        value: debugStack,\n      });\n      Object.defineProperty(element, '_debugTask', {\n        configurable: false,\n        enumerable: false,\n        writable: true,\n        value: debugTask,\n      });\n    }\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  if (!disableDefaultPropsExceptForClasses) {\n    // Resolve default props\n    if (type && type.defaultProps) {\n      const defaultProps = type.defaultProps;\n      for (const propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,\n      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,\n      __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,\n    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    if (!enableOwnerStacks && !isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn here so that we can get better stack traces but with enableOwnerStacks\n      // enabled we don't need this because we get good stacks if we error in the\n      // renderer anyway. The renderer is the only one that knows what types are valid\n      // for this particular renderer so we let it error there instead.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      let info = '';\n      if (\n        type === undefined ||\n        (typeof type === 'object' &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info +=\n          ' You likely forgot to export your component from the file ' +\n          \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      let typeString;\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;\n        info =\n          ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      console.error(\n        'React.jsx: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    } else {\n      // This is a valid element type.\n\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      // When enableOwnerStacks is on, we no longer need the type here so this\n      // comment is no longer true. Which is why we can run this even for invalid\n      // types.\n      const children = config.children;\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (let i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            console.error(\n              'React.jsx: Static children should always be an array. ' +\n                'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n                'Use the Babel transform instead.',\n            );\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (!disableDefaultPropsExceptForClasses) {\n      // Resolve default props\n      if (type && type.defaultProps) {\n        const defaultProps = type.defaultProps;\n        for (const propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    if (!enableOwnerStacks && !isValidElementType(type)) {\n      // This is just an optimistic check that provides a better stack trace before\n      // owner stacks. It's really up to the renderer if it's a valid element type.\n      // When owner stacks are enabled, we instead warn in the renderer and it'll\n      // have the stack trace of the JSX element anyway.\n      //\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      let info = '';\n      if (\n        type === undefined ||\n        (typeof type === 'object' &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info +=\n          ' You likely forgot to export your component from the file ' +\n          \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      let typeString;\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;\n        info =\n          ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      console.error(\n        'React.createElement: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    } else {\n      // This is a valid element type.\n\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      for (let i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], type);\n      }\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ && enableOwnerStacks ? Error('react-stack-top-frame') : undefined,\n    __DEV__ && enableOwnerStacks ? createTask(getTaskName(type)) : undefined,\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && enableOwnerStacks ? oldElement._debugStack : undefined,\n    __DEV__ && enableOwnerStacks ? oldElement._debugTask : undefined,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    clonedElement._store.validated = oldElement._store.validated;\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    let defaultProps;\n    if (\n      !disableDefaultPropsExceptForClasses &&\n      element.type &&\n      element.type.defaultProps\n    ) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        if (\n          !disableDefaultPropsExceptForClasses &&\n          config[propName] === undefined &&\n          defaultProps !== undefined\n        ) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && enableOwnerStacks ? element._debugStack : undefined,\n    __DEV__ && enableOwnerStacks ? element._debugTask : undefined,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    if (enableOwnerStacks) {\n      // When owner stacks is enabled no warnings happens. All we do is\n      // mark elements as being in a valid static child position so they\n      // don't need keys.\n      if (isValidElement(node)) {\n        if (node._store) {\n          node._store.validated = 1;\n        }\n      }\n      return;\n    }\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) {\n      // This is a reference to a client component so it's unknown.\n    } else if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        const child = node[i];\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    } else {\n      const iteratorFn = getIteratorFn(node);\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          const iterator = iteratorFn.call(node);\n          if (iterator !== node) {\n            let step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n\nconst ownerHasKeyUseWarning = {};\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (enableOwnerStacks) {\n    // Skip. Will verify in renderer instead.\n    return;\n  }\n  if (__DEV__) {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n    element._store.validated = 1;\n\n    const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n    let childOwner = '';\n    if (element && element._owner != null && element._owner !== getOwner()) {\n      let ownerName = null;\n      if (typeof element._owner.tag === 'number') {\n        ownerName = getComponentNameFromType(element._owner.type);\n      } else if (typeof element._owner.name === 'string') {\n        ownerName = element._owner.name;\n      }\n      // Give the component that originally created this child.\n      childOwner = ` It was passed a child from ${ownerName}.`;\n    }\n\n    const prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n    ReactSharedInternals.getCurrentStack = function () {\n      const owner = element._owner;\n      // Add an extra top frame while an element is being validated\n      let stack = describeUnknownElementTypeFrameInDEV(\n        element.type,\n        owner ? owner.type : null,\n      );\n      // Delegate to the injected renderer-specific implementation\n      if (prevGetCurrentStack) {\n        stack += prevGetCurrentStack() || '';\n      }\n      return stack;\n    };\n    console.error(\n      'Each child in a list should have a unique \"key\" prop.' +\n        '%s%s See https://react.dev/link/warning-keys for more information.',\n      currentComponentErrorInfo,\n      childOwner,\n    );\n    ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  if (__DEV__) {\n    let info = '';\n    const owner = getOwner();\n    if (owner) {\n      const name = getComponentNameFromType(owner.type);\n      if (name) {\n        info = '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n    if (!info) {\n      const parentName = getComponentNameFromType(parentType);\n      if (parentName) {\n        info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n      }\n    }\n    return info;\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","getOwner","hasValidKey","config","key","undefined","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","ref","element","$$typeof","jsxProd","maybeKey","propName","jsx","jsxs"],"mappings":";;AAiBO,MAAMA,kBAAkB,GAC3BC,MAAM,CAACC,GAAP,CAAW,4BAAX,CADyD,CAAtD,CAAA;AAIA,MAAMC,mBAAmB,GAAWF,MAAM,CAACC,GAAP,CAAW,gBAAX;;ACmC3C,SAASE,QAAT,GAAoB;;AAQlB,EAAA,OAAO,IAAP,CAAA;AACD,CAAA;;AAsBD,SAASC,WAAT,CAAqBC,MAArB,EAA6B;;AAS3B,EAAA,OAAOA,MAAM,CAACC,GAAP,KAAeC,SAAtB,CAAA;AACD,CAAA;AA2CD;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAASC,YAAT,CACEC,IADF,EAEEH,GAFF,EAGEI,IAHF,EAIEC,MAJF,EAKEC,KALF,EAMEC,KANF,EAOEC,UAPF,EAQEC,SARF,EASE;AACA;AACA;AACA;AACA;AACA,EAAA,MAAMC,OAAO,GAAGH,KAAK,CAACI,GAAtB,CALA;AAQA;;AACA,EAAMA,MAAAA,GAAG,GAAGD,OAAO,KAAKT,SAAZ,GAAwBS,OAAxB,GAAkC,IAA9C,CAAA;AAEA,EAAA,IAAIE,OAAJ,CAAA;;AACA,EA2CO;AACL;AACAA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,QAAQ,EAAEpB,kBAFF;AAIR;AACAU,MAAAA,IALQ;AAMRH,MAAAA,GANQ;AAORW,MAAAA,GAPQ;AASRJ,MAAAA,KAAAA;AATQ,KAAV,CAAA;AAWD,GAAA;;AA8CD,EAAA,OAAOK,OAAP,CAAA;AACD,CAAA;AAED;;;;;;;;AAMO,SAASE,OAAT,CAAiBX,IAAjB,EAAuBJ,MAAvB,EAA+BgB,QAA/B,EAAyC;AAC9C,EAAA,IAAIf,GAAG,GAAG,IAAV,CAD8C;AAI9C;AACA;AACA;AACA;AACA;;AACA,EAAIe,IAAAA,QAAQ,KAAKd,SAAjB,EAA4B;;AAI1BD,IAAAA,GAAG,GAAG,EAAA,GAAKe,QAAX,CAAA;AACD,GAAA;;AAED,EAAA,IAAIjB,WAAW,CAACC,MAAD,CAAf,EAAyB;;AAIvBC,IAAAA,GAAG,GAAG,EAAKD,GAAAA,MAAM,CAACC,GAAlB,CAAA;AACD,GAAA;;AAED,EAAA,IAAIO,KAAJ,CAAA;;AACA,EAAA,IAAI,EAAE,KAAA,IAASR,MAAX,CAAJ,EAAwB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,IAAAA,KAAK,GAAGR,MAAR,CAAA;AACD,GAXD,MAWO;AACL;AACA;AACA;AACAQ,IAAAA,KAAK,GAAG,EAAR,CAAA;;AACA,IAAA,KAAK,MAAMS,QAAX,IAAuBjB,MAAvB,EAA+B;AAC7B;AACA,MAAIiB,IAAAA,QAAQ,KAAK,KAAjB,EAAwB;AACtBT,QAAAA,KAAK,CAACS,QAAD,CAAL,GAAkBjB,MAAM,CAACiB,QAAD,CAAxB,CAAA;AACD,OAAA;AACF,KAAA;AACF,GAAA;;AAcD,EAAA,OAAOd,YAAY,CACjBC,IADiB,EAEjBH,GAFiB,EAGjBC,SAHiB,EAIjBA,SAJiB,EAKjBJ,QAAQ,EALS,EAMjBU,KANiB,CAAnB,CAAA;AAUD;;AC1VKU,MAAAA,GAAG,GAELH;AAEJ;;AACA,MAAMI,IAAI,GAENJ;;;;;;"}